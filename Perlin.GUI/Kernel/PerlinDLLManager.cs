using System;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Perlin.GUI.Models;
using Perlin.GUI.Models.RunParameters;

namespace Perlin.GUI.Kernel
{
    /// <summary>
    /// Bridge between GUI and DLL functions.
    /// Provides exchange of data gained from user and data generated by program.
    /// It's also obligated to divide word for threads.
    /// </summary>
    class PerlinDllManager
    {
        #region Import DLLs
        #region PureC
        [DllImport("libs\\Perlin.PureC.dll", EntryPoint = "Init", CallingConvention = CallingConvention.Cdecl)]
        private static extern void InitPureC(int width, int height);

        [DllImport("libs\\Perlin.PureC.dll", EntryPoint = "Finalize", CallingConvention = CallingConvention.Cdecl)]
        private static extern void FinalizePureC(int height);

        [DllImport("libs\\Perlin.PureC.dll", EntryPoint = "GeneratePerlinNoiseBitmap", CallingConvention = CallingConvention.Cdecl)]
        private static extern void GeneratePerlinNoiseBitmapC(ThreadParameters threadParameters);
        #endregion // PureC

        #region Assembly
        [DllImport("libs\\Perlin.Assembly.dll", EntryPoint = "_Init", CallingConvention = CallingConvention.Cdecl)]
        private static extern void InitAsm(int width, int height);

        [DllImport("libs\\Perlin.Assembly.dll", EntryPoint = "_Finalize", CallingConvention = CallingConvention.Cdecl)]
        private static extern void FinalizeAsm(int height);

        [DllImport("Perlin.Assembly.dll", EntryPoint = "_PerlinNoiseBmp", CallingConvention = CallingConvention.Cdecl)]
        private static extern void GeneratePerlinNoiseBitmapAssembly(ThreadParameters threadParameters);
        #endregion // Assembly
        #endregion // Import DLLs

        #region Fields
        private readonly GeneratorParameters _generatorParameters;
        private byte[] GeneratedFileArray { get; set; }
        #endregion // Fields

        #region Constructor
        public PerlinDllManager(GeneratorParameters generatorParameters)
        {
            int npad = (3 * generatorParameters.Width * sizeof(byte)) & 3;
            if (npad != 0)
            {
                npad = 4 - npad;
            }

            int fileSizeInBytes = 54 + generatorParameters.Height * (3 * generatorParameters.Width + npad * sizeof(byte));

            GeneratedFileArray = new byte[fileSizeInBytes];
            _generatorParameters = generatorParameters;

            if(generatorParameters.GeneratingLibrary == Library.PureC)
            {
                InitPureC(generatorParameters.Width, generatorParameters.Height);
            }
            else
            {
                InitAsm(generatorParameters.Width, generatorParameters.Height);
            }
        }
        #endregion // Constructor

        #region Compute threads params and run
        public async Task<byte[]> GeneratePerlinNoiseFileAsync()
        {
            var tasks = new Task[_generatorParameters.NumberOfThreads];

            for (int thread = 0; thread < tasks.Length; thread++)
            {
                var tempThread = thread;
                tasks[thread] = Task.Run(() =>
                {
                    var thisThreadParams = ComputeThreadParameters(tempThread);
                    RunSingleThread(thisThreadParams);
                });
            }
            await Task.WhenAll(tasks);

            if (_generatorParameters.GeneratingLibrary == Library.PureC)
            {
                FinalizePureC(_generatorParameters.Height);
            }
            else 
            {
                FinalizeAsm(_generatorParameters.Height);
            }
            return GeneratedFileArray;
        }

        private ThreadParameters ComputeThreadParameters(int threadId)
        {
            var thisThreadFileHeight = 0;
            var currentOffset = 0;
            for (int i = 0; i <= threadId; i++)
            {
                thisThreadFileHeight = ComputeNumberOfLinesForCurrentThread(i);
                if (i != threadId)
                    currentOffset += thisThreadFileHeight;
            }
            return new ThreadParameters()
            {
                ThreadId = threadId,
                NumberOfThreads = _generatorParameters.NumberOfThreads,
                CurrentImageOffset = currentOffset,
                ImageWidth = (uint)_generatorParameters.Width,
                ImageHeight = (uint)_generatorParameters.Height,
                CurrentImageHeight = (uint)thisThreadFileHeight,
                NumberOfOctaves = _generatorParameters.NumberOfOctaves,
                Persistence = _generatorParameters.Persistence,
                NoiseColor = _generatorParameters.Color,
                NoiseEffect = (int)_generatorParameters.BitmapEffect
            };
        }

        private int ComputeNumberOfLinesForCurrentThread(int threadId)
        {
            var numberOfThreads = _generatorParameters.NumberOfThreads;
            var imgHeight = _generatorParameters.Height;
            var numberOfLines = (imgHeight / numberOfThreads);

            if (numberOfThreads > 1)
            {
                if ((numberOfLines % numberOfThreads) != 0)
                {
                    if (threadId == (numberOfThreads - 1))
                    {
                        numberOfLines = (imgHeight - (threadId * numberOfLines));
                    }
                }
            }
            return numberOfLines;
        }

        private unsafe void RunSingleThread(ThreadParameters currendThreadParameters)
        {
            fixed (byte* fileArray = GeneratedFileArray)
            {
                currendThreadParameters.ImageByteArrayPointer = (uint*)(fileArray);
                switch (_generatorParameters.GeneratingLibrary)
                {
                    case Library.Asm:
                        GeneratePerlinNoiseBitmapAssembly(currendThreadParameters); 
                        break;
                    case Library.PureC:
                        GeneratePerlinNoiseBitmapC(currendThreadParameters);
                        break;
                    default:
                        break;
                }
            }
        }
        #endregion // Compute threads params and run
    }
}
